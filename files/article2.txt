Methods and data structures for the implementation of a database of a social network recommender system
Authors of the publication: Mihav V.V., Meleshko E.V., Shimko S.V. Central Ukrainian National Technical University,
Abstract
The purpose of this work is the research and software implementation of methods and data structures for building a database of a recommender system in order to compare the efficiency of their use in terms of time and memory consumption. The presence of a large number of different methods of implementing databases calls for a comparative analysis and selection of the optimal method and data structure for storing information in recommender systems.
Various data structures that can be used to build a recommender system database have been investigated, including linked list, expanded linked list, hash table, B-tree, B+-tree and binary decision diagram. A series of experiments was also conducted on a software simulation model of a recommender system with different numbers of agents, subjects, and sessions.
According to the results of the conducted experiments, the expanded list showed the best indicators of speed and memory usage. The B+-tree structure showed results close to the hash table. The access time to a single element is constant in both cases, but the B+ tree has certain advantages - the elements are kept sorted, and there is no need to expand the memory area when resizing. The binary decision diagram data structure showed the worst results both in terms of time and memory consumption. Profiling showed that 75% of the test run time of the expanded list variant was spent generating random data for software simulations of recommender system agents and items, so the data store itself has high performance.
Profiling of the inverted list variant showed that access to random blocks takes longer due to the inability to cache them, so under real-world load conditions the time to insert new data will be longer, and the relative efficiency of using an inverted list will increase. For the most efficient use of memory, the block size of the linked list should be adapted so that the blocks are as full as possible. Small size blocks reduce memory waste, but increase the time it takes to traverse all the elements of the list and increase the memory overhead.
Keywords: recommendation systems, databases, data structures, software simulation model.
Article
Formulation of the problem. Recommender systems are an important component of social networks and significantly influence how users perceive the information space [1, 2]. The choice of the method of presentation of the data used by the recommender system is important, because an effective way of building a database for the operation of such a system can reduce the number of required resources and increase the number of available algorithms for the formation of recommendation lists. Therefore, the choice of DBMS implementation methods for storing recommendation system data is an important scientific and practical task.
Analysis of recent research and publications. Nowadays, there are many different database management systems, in addition to relational databases, NoSQL databases are widely used [3, 4]. DBMS of the NoSQL type can be implemented by various methods, in particular, as Key-value stores, Scalable distributed stores (Column Family (Bigtable) stores), graph DBMS (Graph Stores), document-oriented DBMS ( Document Stores) etc. [3-5].
The method of data storage of the recommender system is important from the point of view of the quality of its work, speed, scaling capabilities, ease of performing basic operations with data for the formation of recommendations.
Increasingly, graph models are being used for data storage of recommender systems and other applications [6-8], also the graph form of data representation is becoming common in software modeling of complex systems and networks [9-12], and this is due to a number of advantages of graph models [8 , 13]. A clear example of such an approach is the construction of recommender systems using the Neo4j graph DBMS [14]. DBMS graph models provide not only a convenient data storage format, but also a convenient query format. The documentation for Neo4j contains examples of the implementation of algorithms for generating recommendations by queries to this DBMS, which illustrates its suitability for use in recommender systems.
The presence of such a large number of different methods of implementing databases and presenting information, which can be used in the construction of recommender systems, calls for a comparative analysis and selection of the optimal method and data structure for storing information of recommender systems.
Setting objectives. The purpose of this work is research and software implementation of methods and data structures for the implementation of a recommender system database in order to compare the efficiency of their use in terms of time and memory consumption.
To achieve the goal, a research program has been defined, which consists of the following tasks: - Research of existing data structures for information storage and methods of their implementation. - Software implementation of researched data structures to create a recommendation system database. - Carrying out a series of experiments to compare the efficiency of using the considered data structures in terms of time and memory consumption.
The object of the study is the data storage process of the recommender system. The subject of the research is the methods and data structures for the implementation of the recommender system database. Research methods are based on software development methods, the theory of database construction, the theory of algorithms, and the theory of statistical data processing.
Presenting main material. The article examines various data structures that can be used to create a recommendation system database [15-17]. We will present the classification of data structures that were selected for research and are suitable for solving the task.
A linked list is a data structure in which each element has a pointer to the next element. The main advantage of this structure is the constant time of adding a new element. However, a new block of memory must be allocated for each element, causing the memory manager to incur significant latency and memory overhead.
An unrolled linked list is a linked list, each element of which contains an array of logical elements. This allows you to combine the advantages of arrays and linked lists in the case of adding elements to the end of the list. Combining blocks of logical elements into a list allows you to add new elements without changing the size of the memory block, save memory on pointers and use the processor cache more efficiently due to the sequential arrangement of elements. With sequential filling, it is guaranteed that no more than one block of elements will remain unfilled.
A hash table (hash map) is a data structure in which an element is searched based on its key. The hash from the key indicates in which cell the element is located. If several elements have the same hash, a collision occurs. There are two methods of conflict resolution - closed and open addressing. With closed addressing, each table element is a linked list and all elements with the same hash are added to the same list. This is the simplest way to resolve collisions, but it uses extra memory for pointers and does not allow you to take advantage of caching when traversing hash table elements. With open addressing, in the event of a collision, a new position of the element is selected. The new position can be chosen both with the help of an additional hash function and by shifting the position by several elements. The search is repeated until an empty element is reached. Open addressing uses a fixed amount of memory and does not require additional pointers, but for insert and lookup operations to be efficient, the table must be filled no more than 50%, so this causes additional memory costs.
A b-tree is a data structure represented by a balanced, highly branched search tree. Each node of the B-tree, except for the leaves, is an ordered list in which keys and pointers to descendants alternate. Node keys specify the interval in which child keys are located. A B+-tree differs in that it stores all values in leaf nodes, and leaf nodes have a neighbor reference, so it is possible to traverse all values without traversing the entire tree. The large branching of the tree keeps the tree height small, allowing for a small amount of data to be browsed in a single pass, and the construction rules keep values in ascending key order.
Binary Decision Diagrams (BDDs) are an economical form of representing Boolean functions as a directed acyclic graph. The vertices of the graph represent the arguments of the function, the leaves - its binary values. To add and remove edges and change the weight of edges, you must be able to edit the graph data. BDRs make it possible to store data in a compressed form and quickly obtain the value of a function by its parameters, but editing BDRs requires complex calculations. When representing Boolean functions in the form of BDR, it became possible to solve many problems that cannot be solved with traditional representations of structures due to the significant dimension of such representations and the complexity of operations on them. BDRs can be successfully applied in virtually every industry where discrete data structures need to be processed.
A series of experiments was conducted to compare the efficiency of using the considered data structures in terms of time and memory consumption. The results of the experiments are shown in Tables 1-2 and Figures 1-2.
The experiments were performed on a computer with an AMD Ryzen 5 3600 processor and 32 GB of RAM. Collaborative filtering was used to generate recommendations. In order to simulate the recommender system, a software simulation model was developed, in which three main entities - agent, session and subject - were highlighted. On this software model and experiments were conducted.
The created software simulation model of the recommender system for conducting experiments works according to the following principle: Step 1. Initialization of the recommender system: the number of agents, subjects, and sessions, as well as the session size and the maximum number of likes, are set.
Step 2. For each agent, 1 to n preferences are randomly generated.
Step 3. m sessions are created. A randomly selected agent is assigned to each session. Then 1 to k preferences are randomly selected from this agent's preferences and copied to the session.
Step 4. A control session for which a recommendation will be generated is randomly selected.
Step 5. All subjects belonging to the control session are determined.
Step 6. All sessions whose preferences overlap with the preferences of the control session are searched. At this stage, it is possible to filter sessions by the size of the intersection.
Step 7. Items to be recommended are determined. Searches for all items that belong to at least one of the selected sessions, but do not belong to the control session. At this stage, it is possible to filter subjects by the number of fixed sessions.
4 series of experiments were conducted. Below are the parameters of each series.
Parameters of experiment series 1: number of agents 65536, number of items 131072, number of sessions 262144, session size 192, maximum number of likes 1536.
Parameters of experiment series 2: number of agents 131072, number of items 262144, number of sessions 524288, session size 256, maximum number of likes 2048.
Parameters of experiment series 3: number of agents 262144, number of items 524288, number of sessions 1048576, session size 256, maximum number of likes 2048.
Parameters of Experiment Series 4: number of agents 524288, number of items 1048576, number of sessions 2097152, session size 256, maximum number of likes 2048.
Table 1 shows the results of a series of experiments conducted to compare the time of formation of recommendations by the system when using different data structures for the implementation of the database.
Based on the results obtained from Table 1, the graph shown in Figure 1 was constructed. As can be seen from the table and the figure, the following data structures showed the best results in terms of the time of formation of recommendations - a normal expanded list and an inverted expanded list. The B+-tree data structure also showed good results.
Table 2 shows the results of a series of experiments conducted to compare the amount of memory used to generate recommendations by the system when using different data structures to implement the database.
Based on the results obtained from Table 2, the graph shown in Figure 2 was constructed. As can be seen from the table and figure, the best results in terms of memory used for the formation of recommendations, similarly to the results in terms of time, were shown by the following data structures - a normal expanded list , an inverted spanning list, and a B+-tree.
Profiling the test code showed that the significant difference in session generation time between variants with and without the inverted list is caused by the delay in accessing the elements of the inverted list, since different elements are constantly being accessed. With real data, the expanded list solution will run slightly slower because caching will be less efficient.
The structure of the expanded list is very simple, so in the future it will make it possible to use multi-threaded work without blocking.
The B+ tree structure showed results close to the hash table. The access time to a single element is constant in both cases, but the B+ tree has certain advantages: the elements are kept sorted, and there is no need to expand the memory area when resizing.
The block size of the expanded list affects the speed of operation and the amount of memory used. Reducing the block size reduces memory loss, but increases the time to access elements.
To speed up the search for individual elements in the expanded list, after filling the block, you can sort its elements. This will make it possible to use a binary search instead of a linear one and check only those blocks where the searched element belongs to the interval formed by the smallest and largest elements of the block.
The advantage of the expanded list over the other data structures considered in memory usage is largely due to the fact that only the fact of preference is stored, with no parameters. When using 4 bytes per element to store the parameter, the memory consumption approaches the maximum consumption of binary decision diagrams.
Conclusions. According to the results of the conducted experiments, the expanded list showed the best indicators of speed and memory usage. Profiling showed that 75% of the test run time of the expanded list variant was spent generating random data for software simulations of recommender system agents and items, so the data store itself has high performance. Profiling of the inverted list variant showed that access to random blocks takes longer due to the inability to cache them, so under real-world load conditions the time to insert new data will be longer, and the relative efficiency of using an inverted list will increase. For the most efficient use of memory, the block size of the linked list should be adapted so that the blocks are as full as possible. Small size blocks reduce memory waste, but increase the time it takes to traverse all the elements of the list and increase the memory overhead.
literature
1. Editors Ricci F., Rokach L., Shapira B., Kantor P. B. Recommender Systems Handbook. New York, NY, USA: Springer-Verlag New York, Inc., 2010. 842 p.
2. Valois B.Jr.C., Oliveira M.A. Recommender systems in social networks. JISTEM J.Inf.Syst. Technol. Manag. 2011. Vol.8 No.3. P. 681-716. URL: https://www.scielo.br/scielo.php?script=sci_arttext&pid=S1807-17752011000300009 (Last accessed: 04/02/2021)
3. Fowler M., Sadalaj P.J. NoSQL: A new methodology for developing non-relational databases. M.: "Williams" publishing house. 2013. 192 p.
4. Meier A., Kaufmann M. SQL & NoSQL databases. Springer Vieweg, Wiesbaden. 2019. P. 201-218. URL: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.468.7089&rep=rep1&type=pdf (Last accessed: 04/02/2021)
5. Cure O., Blin G. RDF database Systems: Triples Storage and SPARQL Query Processing. Elsevier Science. 2014. 256 p.
6. Yi N., Li C., Feng X., Shi M. Design and implementation of movie recommender system based on graph database. 14th Web Information Systems and Applications Conference (WISA), IEEE. 2017. P. 132-135.
7. Angles R. A comparison of current graph database models. IEEE 28th International Conference on data Engineering Workshops, IEEE. 2012. P. 171-177.
8. Zasyadko G.E., Karpov A.V. Problems of graphic database development. Don's engineering journal. 2017. No. 1(44). URL: https://cyberleninka.ru/article/n/problemy-razrabotki-grafovyh-baz-dannyh (access date: 04/02/2021)
9. Melkov S., Musatov D., Savvateev A. Modeling of social networks. 2013. URL: https://kpfu.ru/docs/F117464271/MMS_socnet_cities.pdf (access date: 04/02/2021)
10. Bernovsky M.M., Kuzyurin N.N. Random graphs, models and generators of scale-free graphs. Proceedings of the Academy of Sciences of the Russian Academy of Sciences. 2012. URL: https://cyberleninka.ru/article/n/sluchaynye-grafy-modeli-i-generatory-bezmasshtabnyh-grafov (access date: 04/02/2021)
11. Raigorodsky A.M. Mathematical models of the Internet. "Quantum". 2012. No. 4. P. 12-16. URL: https://elementy.ru/nauchno-populyarnaya_biblioteka/431792 (access date: 04/02/2021)
12. Meleshko Ye. Computer model of virtual social network with recommendation system. Scientific journal Innovative Technologies and Scientific Solutions for Industries, Kharkiv, NURE. 2019. Issue 2(8). P. 80
13. Robinson Ya., Weber D., Eifrem E. Graph data bases: new possibilities for working with related data. M.: DMK Press. 2016. 256 p.
14. Neo4j Documentation. 2020. URL: https://neo4j.com/docs (Last accessed: 04/02/2021)
15. Aho A.V., Hopcroft D., Ulman D.D. data structures and algorithms. M.: Williams, 2000. 384 p.
16. Minato S. Zero-suppressed BDDs and their applications. International Journal on Software Tools for Technology Transfer. 2001. No. 3.2. pp. 156-170.
17. Knut D.E. The Art of Programming, Volume 4A. Combinatorial algorithms. Part 1. Moscow: Williams. 2013. 960 p.